# depending on platform, add more
if [ "$(uname)" = "Darwin" ]; then
    fpath+="$BREW_PREFIX/share/zsh-completions"
    fpath+="$BREW_PREFIX/share/zsh/site-functions"
elif [ "$(uname)" = "Linux" ]; then
    if [ -f "/etc/arch-release" ]; then
        # arch has it already done in a proper dir
    elif [ -f "/etc/debian_version" ]; then
        fpath+="/usr/local/share/zsh/plugins/zsh-completions/src"
    fi
fi
# local user folder for custom autocompletion functions
fpath+="${ZDOTDIR}/zfunc"
# this requires nix-zsh-completions plugin installed in 'plugins' file here
fpath+="${ZDOTDIR}/remote/nix-zsh-completions"

# autocompletion
autoload -Uz compinit; compinit
# bash-compatible mode
autoload -Uz bashcompinit; bashcompinit
# use cache
zstyle ':completion::complete:*' use-cache 1
# autocompletion menu
zstyle ':completion:*' menu select
# shift-tab to go back in completions
bindkey '^[[Z' reverse-menu-complete
# autocomplete with sudo
zstyle ':completion::complete:*' gain-privileges 1
# case insensitive and partial
zstyle ':completion:*' matcher-list '' 'm:{a-zA-Z}={A-Za-z}' 'r:|[._-]=* r:|=*' 'l:|=* r:|=*'
# Defining the Completers
zstyle ':completion:*' completer _extensions _complete _approximate
# display completer while waiting
zstyle ":completion:*" show-completer true

# bash completion made lazy
completers=(
    pipx "register-python-argcomplete pix" _python_argcomplete
    az "register-python-argcomplete az" _python_argcomplete
)
# arrays in zsh start with 1 :')
for ((i=1; i<${#completers[@]}; i+=3)); do
    local cmd="${completers[i]}"
    local completer="${completers[i+1]}"
    local ccmd="${completers[i+2]}"

    eval "
        _lazycomplete_$cmd() {
            if command -v $cmd &>/dev/null; then
                unset -f _lazycomplete_$cmd
                source <($completer)
                $ccmd \"\$@\"
            fi
        }
        complete -F _lazycomplete_$cmd $cmd
    "
done

# lazy load zsh completion
completers=(
    kubectl "kubectl completion zsh"
    helm "helm completion zsh"
    k3d "k3d completion zsh"
    kind "kind completion zsh"
    flux "flux completion zsh"
    tilt "tilt completion zsh"
    poetry "poetry completions zsh"
    rustup "rustup completions zsh rustup"
    cargo "rustup completions zsh cargo"
)
for ((i=1; i<${#completers[@]}; i+=2)); do
    local cmd="${completers[i]}"
    local completer="${completers[i+1]}"

    eval "
        function _lazycomplete_$cmd {
            if command -v $cmd &>/dev/null; then
                unfunction _lazycomplete_$cmd
                # if a dedicated completions file is already handled by package manager
                # do nothing
                if [ ! -f $ZSH_VENDOR_COMPLETIONS/_$cmd ]; then
                    compdef -d $cmd
                    source <($completer)
                    # find the completion function we just sourced, some names are non-deterministic
                    local ccmd=\$(print -l \${(ok)functions[(I)_*]} | grep \"$cmd\" | grep --invert-match \"^__\" | grep --invert-match \"debug\" | head -n 1)
                    # just in case, some generator commands expect to pass this manually, like tilt
                    # and some generate the command badly, like poetry. This is a mess
                    compdef \$ccmd $cmd
                    \$ccmd \"\$@\"
                else
                    # it is already provided by package manager
                fi
            fi
        }
        compdef _lazycomplete_$cmd $cmd
    "
done

# generate functions and store them in files for autoload by zsh
# (not using this right now but keep for reference, may come in handy)
generate_completions() {
    zfunc_completions_helper "glab completion --shell zsh" _glab

    # force compinit
    rm -f "$ZDOTDIR/.zcompdump"
    echo "completions generated; you may need to restart your shell"
}
